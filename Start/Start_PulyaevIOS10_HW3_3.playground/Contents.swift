import UIKit
//: Домашнее задание необходимо выполнить в данном файле, перед отправкой переименуйте название файла (латиницей) в формате ФамилияГруппаDZ4_3, например, *IvanovIOS4_DZ4_3*, заархивировать и приложить в личном кабинете для проверки.
/*:
 Чтобы успешно выполнить это домашнее задание, необходимо усвоить следующие темы:
 * [Коллекции eng.](https://docs.swift.org/swift-book/LanguageGuide/CollectionTypes.html)
 * [Коллекции  рус.](https://swiftbook.ru/content/languageguide/collection-types/)
 * [Управление потоком eng.](https://docs.swift.org/swift-book/LanguageGuide/ControlFlow.html)
 * [Управление потоком рус.](https://swiftbook.ru/content/languageguide/control-flow/)
 * [Функции eng.](https://docs.swift.org/swift-book/LanguageGuide/Functions.html)
 * [Функции рус.](https://swiftbook.ru/content/languageguide/functions/)
*/
//: ## Задача №1
//: В данной задаче Вы тренируетесь Добавлять и Удалять значения в **`Хранилище (массив)`** при помощи двух функций, которые Вам и нужно реализовать. Функции принимают значение, но ничего не возвращают.
//: Первая функция добавляет элемент в массив, вторая функция удаляет элемент из массива, вы сами можете выбрать любой удобный для вас вариант добавления и удаления элементов из массива.
//: ### Алгоритм решения:
//:  * Создайте пустой массив строк типа String на любимую тематику, например, это будет Хранилище столовых приборов (этот пример не использовать), в который вы будете поочередно добавлять или удалять ложки, вилки и т.п. приборы.
//: * Создайте 2 функции в соответствии с условием.
//: * Попробуйте добавлять и удалять значения в массиве при помощи созданных функций.
//: * Что произойдет, если попытаетесь удалить значение, которого нет в Хранилище? Напишите, что в этом случае вы можете изменить в своей функции и внесите в нее изменения.
//: * *(условие со звездочкой - не обязательное) обе функции должны принимать массив и значение. Они должны добавлять или удалять значения в массиве. Функция удаления должна быть безопасной, т.е. если Хранилище пустое, мы должны сообщить об этом пользователю, если запрашиваемое на удаление значение отсутствует, необходимо также сообщить, что такого элемента нет. Запрещается использование forced unwrapping, если в вашем варианте будет необходимость работать с опционалами.*
// Решение задачи №1:
//Создаем массив с фильмами
var movies = ["Джентельмены", "Star Wars", "Один дома", "Список Шиндлера", "Начало"]

//Создаем функцию добавления фильмов
func addNewMovie(newMovie: String? = nil, newMovieList: [String] = []) {
    
    //Проверяем есть ли значения во входящем массиве
    if newMovieList.isEmpty {
        
        //Значения в массиве отсутствуют. Проверяем входящую строку
        if let movieName = newMovie {
            movies.insert(movieName, at: movies.endIndex)
        } else {
            print("Ошибка добавления. Нет входящих значений")
        }
        
    } else {
        movies += newMovieList
    }
    
}

//Создаем функцию удаления фильмов
func deleteMovie(oldMovie: String? = nil, oldMovieList: [String] = []) {
    
    //Проверяем есть ли значения во входящем массиве
    if oldMovieList.isEmpty {
        
        if let movieName = oldMovie {
            //Ищем индекс по названию и проверяем его
            if let movieIndex = movies.firstIndex(of: movieName) {
                movies.remove(at: movieIndex)
            } else {
                print("Ошибка удаления. Такого фильма не существует. Введенное название \"\(movieName)\"")
            }
        } else {
            print("Ошибка удаления. Вы не ввели название удаляемого фильма")
        }
        
    } else {
        //Значения в массиве отсутствуют. Проверяем входящую строку
        for deleteMovieName in oldMovieList {
            //Ищем индекс по названию и проверяем его
            if let movieIndex = movies.firstIndex(of: deleteMovieName) {
                //Все ок, удаляем фильм по индексу
                movies.remove(at: movieIndex)
            } else {
                print("Ошибка удаления. Такого фильма не существует. Введенное название \"\(deleteMovieName)\"")
            }
        }
    }

}

//Добавляем один фильм в список
addNewMovie(newMovie: "История Игрушек")

//Добавляем много фильмов в список
addNewMovie(newMovieList: ["Иван Васильевич меняет профессию", "Ирония судьбы или С легким паром", "Ночь перед рождеством"])

//Выводим список всех фильмов
print(movies)

//Удаляем один фильм
deleteMovie(oldMovie: "Один дома")

//Удаляем несколько фильмов, с намеренными ошибками
deleteMovie(oldMovieList: ["Один дома", "История Игрушек", "Один дома 2", "Список Шиндлера", "Ночь перед рождеством"])

print(movies)
//: ## Задача №2
//: Вы получили тестовое задание от службы доставки еды: преобразовать бонусные баллы клиентов, которые хранятся на сайте, в денежные единицы. Со стороны сайта приходит словарь, содержащий ID клиента **(Int)** и накопленную сумму Бонусов **(Double)**. Ваша задача вернуть на сайт словарь, содержащий ID клиента **(Int)** и конвертированные денежные единицы **(Int)**, каждые 100 бонусов равны 10 денежным единицам.
//: ### Алгоритм решения:
//: * Словарь со своими значениями создавать не нужно. Значения, с которыми вы будете работать, инкапсулированы и переданы в `userPoints`.
//: * Распечатайте словарь и посмотрите, с какими значениями вы будете работать.
//: * Создайте функцию, которая принимаем словарь, ключом которого будет тип Integer, значением число с плавающей точкой Double, вернуть необходимо словарь ключом и значением, которого будет Integer.
//: * Вызовите функцию и распечатайте полученный результат.
//: * Дополнительно(не обязательно) входящих параметров может быть больше, например, для коэффициента пересчета баллов в денежные единицы.
// Решение задачи №2:
// подготовленный словарь
userPoints

//Выводим словарь
print("\nЗначения до корректировки:\n\(userPoints)\n")

//Создаем функцию для пересчета бонусов с входящими данными в виде Словаря и коэффициента со значением по-умолчанию
func updateUserBonuses (userList: [Int: Double], _ coefficient: Double = 0.1) -> [Int: Int] {
    
    //Создаем внутренний пустой словарь, в который будем добавлять все обновленные значения
    var result: [Int: Int] = [:]
    
    //Проходим циклом по массиву
    for (userId, bonusPoints) in userList {
        let bonusInMoney = Int(bonusPoints*coefficient)
        result[userId] = bonusInMoney
    }
    //Возвращаем результат
    return result
}

//Вызываем функцию
let userMoney = updateUserBonuses(userList: userPoints)

//Выводим обновленный словарь
print("\nЗначения после корректировки:\n\(userMoney)\n")

//: ## Задача №3 (*)
//:  Вам необходимо реализовать функцию, которая принимаем массив опциональных значений типа Integer и возвращает кортеж, в который необходимо передать сумму четных и нечетных значений.
//: - Массив может содержать повторяющиеся и nil значения, например: `[1, 2, nil, 12, 1, nil, 3, 2]`.
//: - В вычислении должны быть использованы только уникальные значения, а повторяющиеся учитываться не должны. Например, у нас повторяются числа 1 и 2, но попадать в результат они должны один раз; сумма нечетных будет `(1 + 3 = 4)`, четных `(2 + 12 = 14)`.
//:  - Так как в массиве могут быть nil, а вернуть необходимо неопциональное значение, необходимо использовать безопасное развертывание опционала (optional binding).
//:  - Для проверки вашего решения передайте в функцию подготовленный массив `arrayOfNumbers`.
//:  - Массив со своими значениями создавать не нужно. Значения, с которыми вы будете работать, инкапсулированы и переданы в `arrayOfNumbers`.
//:  - Распечатайте массив и посмотрите, с какими значениями вы будете работать.
//:  - Если вы все правильно сделаете, то получите ответ: `сумма четных: 1378, нечетных: 1304`.
// Решение задачи №3(*)
// подготовленный массив
arrayOfNumbers

func calculateSumEvenOddValues(from array: [Int?]) -> (Int, Int) {
  // TODO: выполнить код
    //Создаем два пустых множества с четными и нечетными числами, чтобы оставить только уникальные значения
    var uniqueEvenValues: Set<Int> = []
    var uniqueOddValues: Set<Int> = []
    
    //Проходим по массиву с значениями
    for optionalValue in array {
        //Раскрываем опциональные значения
        if let currentValue = optionalValue {
            //Проверяем на четность и, в зависимости от результата, добавляем значение в нужное множество с помощью тернарного оператора
            currentValue % 2 == 0 ? uniqueEvenValues.insert(currentValue) : uniqueOddValues.insert(currentValue)
        }
    }
    
    //Считаем сумму четных и нечетных значений
    let evenSum = uniqueEvenValues.reduce(0, +)
    let oddSum = uniqueOddValues.reduce(0, +)
    
  return (evenSum,oddSum)
}

// проверка решения Задача №3
calculateSumEvenOddValues(from: arrayOfNumbers)


